let canvas;
let ctx;


//onload 
window.onload = function () {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');

}

function main() {
    

    //take the text from the textarea
    let text = document.getElementById('input').value ||

    `The quick brown fox jumps over the lazy dog and the cat is on the roof lanching a space rocket. The parent distribution is a theoretical distribution that is used to generate samples. The samples are generated by taking a number of values from the parent distribution. The samples are then used to calculate statistics such as the mean, variance, and standard deviation. The statistics calculated from the samples are used to estimate the parameters of the parent distribution. The relationship between the parent distribution and the samples statistics is that the samples statistics are used to estimate the parameters of the parent distribution.
    As the number of samples increases, the samples statistics will converge to the parameters of the parent distribution. This is known as the law of large numbers. The law of large numbers states that as the number of samples increases, the sample mean will converge to the population mean, the sample variance will converge to the population variance, and the sample standard deviation will converge to the population standard deviation.`;

// let englishLettersDistribution = [0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015, 0.06094, 0.06966, 0.00153, 0.00772, 0.04025, 0.02406, 0.06749, 0.07507, 0.01929, 0.00095, 0.05987, 0.06327, 0.09056, 0.02758, 0.00978, 0.02360, 0.00150, 0.01974, 0.00074];

let englishLettersDistribution = [
    
    {key : "a" , val: 0.08167},
    {key : "b" , val: 0.01492},
    {key : "c" , val: 0.02782},
    {key : "d" , val: 0.04253},
    {key : "e" , val: 0.12702},
    {key : "f" , val: 0.02228},
    {key : "g" , val: 0.02015},
    {key : "h" , val: 0.06094},
    {key : "i" , val: 0.06966},
    {key : "j" , val: 0.00153},
    {key : "k" , val: 0.00772},
    {key : "l" , val: 0.04025},
    {key : "m" , val: 0.02406},
    {key : "n" , val: 0.06749},
    {key : "o" , val: 0.07507},
    {key : "p" , val: 0.01929},
    {key : "q" , val: 0.00095},
    {key : "r" , val: 0.05987},
    {key : "s" , val: 0.06327},
    {key : "t" , val: 0.09056},
    {key : "u" , val: 0.02758},
    {key : "v" , val: 0.00978},
    {key : "w" , val: 0.02360},
    {key : "x" , val: 0.00150},
    {key : "y" , val: 0.01974},
    {key : "z" , val: 0.00074}
]
    //plot
    //apply ROT13 to the text

    let key = Math.floor(Math.random() * 25) + 1;
    console.log("KEY: ", key);
    let ctext = ROTN(key, text);
    console.log(ctext);

    //predict the text not knowing the key
    let histogram = new Histogram(1, 40, 700, 600, ctx);
    let frequencies = calculateLetterFrequency(ctext);
    
    let freq = frequencies.map((elem)=>elem.val);
    let labels = frequencies.map((elem)=>elem.key);
    histogram.plotHorizontal(freq, 26, labels);
    
    let shift = findCeasarKey(ctext, englishLettersDistribution);
    
    let englishHist = new Histogram(100 + 700, 40, 700, 600, ctx);
    englishLettersDistribution.sort((a, b) => b.val - a.val);
    let englishFreq = englishLettersDistribution.map((elem)=>elem.val);
    let englishLabels = englishLettersDistribution.map((elem)=>elem.key);
    englishHist.plotHorizontal(englishFreq, 26, englishLabels);


    let output = ROTN(26-shift, ctext);
    document.getElementById('output').innerHTML =
    `<strong> Dechiphered Text: </strong>${output}`;

    // encodeRSA(text);
    
}


function findCeasarKey(ct, languageDistribution) {

    let freq = calculateLetterFrequency(ct);
    
    //sort language distribution
    languageDistribution.sort((a, b) => b.val - a.val);

    //compute the shift key difference for the most frequent letter
    let shift = 0;
    let char1 = freq[0].key.charCodeAt(0);
    let char2 = languageDistribution[0].key.charCodeAt(0);

    let distance = char1 - char2;
    if (char1 < char2) {
        distance = distance + 26;
    }
    console.log(char1, String.fromCharCode(char1), char2, String.fromCharCode(char2));
    // console.log(distance);
    shift += Math.abs(distance);

    console.log("SHIFT: ", Math.floor(shift));
    return shift;
}

function encodeRSA(text,N = 10,P = 37){
    let letters = text.split('');
    let ct = "";
    for (x of letters) {
        if (!x.match(/[a-z]/i))
            continue;
        let k = x.toLowerCase().charCodeAt(0) - 97;
        //N^k mod P
        let encoded = Math.pow(N,k) % P;
        // console.log(k,encoded);

        ct += String.fromCharCode(encoded + 97);
    }
    console.log(ct);
    

}

function calculateLetterFrequency(text) {
    let letters = text.split('');
    let valid = [];
    for (x of letters) {
        if (x.match(/[a-z]/i))
            valid.push(x.toLowerCase());
    }
    //divede the counts for the length of valid
    freq = count(valid);

    freq = Object.keys(freq).map(function (key) {
        return { val: freq[key] / valid.length, key };
    }
    );

    freq.sort((a, b) => b.val - a.val);
    return freq;
}

function ROTN(n, str) {
    let result = "";
    for (let i = 0; i < str.length; i++) {
        let c = str.charCodeAt(i);
        if (c >= 65 && c <= 90) {
            result += String.fromCharCode((c - 65 + n) % 26 + 65);
        } else if (c >= 97 && c <= 122) {
            result += String.fromCharCode((c - 97 + n) % 26 + 97);
        } else {
            result += str.charAt(i);
        }
    }
    return result;
}

function generateFromDistribution(distribution, n){
    let values =[];
    let cdf = []
    let cf = 0;
    for (let i = 0; i < distribution.length; i++) {
        const element = distribution[i];
        cdf.push(cf = cf + element);
    }
    //generate n numbers
    for (let i = 0; i < n; i++) {
        let rand = Math.random();

        if(rand < cdf[0]){
            values.push(0);
            continue;
        }
        for (let j = 0; j < cdf.length; j++) {
            if(rand > cdf[j] && rand < cdf[j+1])
            {
                values.push(j+1);
                break; 
            }
        }
        // console.log(rand.toFixed(2), values[values.length-1]);
    }
    // plotFrequencyDistribution(values, 10, 'abs');
    return values;
}

function welfordVariance(arr) {
    let mean = 0;
    let M2 = 0;  // Sum of squared differences
    let n = 0;   // Count of elements
    for (let x of arr) {
        
        n += 1;
        let delta = x - mean;       // Difference between current element and mean
        mean += delta / n;          // Update mean
        let delta2 = x - mean;      // Difference after updating the mean
        M2 += delta * delta2;       // Update the sum of squared differences
    }

    // Variance is M2 divided by the number of elements
    let variance = M2 / n;

    return { mean, variance };
}




// Funzione per contare le occorrenze dei valori in arr
function count(arr) {
    let c = [];
    for (let i = 0; i < arr.length; i++) {
        let value = arr[i];
        if (!c[value]) {
            c[value] = 0;  // Inizializza il conteggio per questo valore
        }
        c[value]++;  // Incrementa il conteggio
    }
    return c;
}


function arrMax(arr){
    let max = 0;
    arr.forEach((elem)=>{
        if (elem>max)
            max = elem
    });
    return max;
}

//Future implementation
class Chart {

    constructor(xPos, yPos, width, height, ctx){
        this.x = xPos;
        this.y = yPos;
        this.width = width;
        this.height = height;
        this.ctx = ctx;
    }
    

    cleanChartArea(){
        // this.ctx.strokeStyle = '';
        this.ctx.fillStyle = 'white';
        // this.ctx.clearRect(this.x, this.y, this.width, this.height);
        this.ctx.fillRect(this.x, this.y, this.width + 1, this.height + 1);
    }   
    
    drawChartArea() {
        this.ctx.strokeStyle = 'black';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.rect(this.x + 40, this.y, this.width -40, this.height);
        this.ctx.stroke();
        this.ctx.closePath();
        }   
}

class Histogram extends Chart {

    constructor(xPos, yPos, width, height, ctx) {
        super(xPos,yPos,width, height, ctx)
    }

    //
    plotHorizontal = (frequencies, intervals , labels = undefined) => {
    
        let maxVal = arrMax(frequencies); //find the maximum
        let barWidthUnit = (this.width - 40)/maxVal;
        // let xPlot = this.xPos + numAttack*step;    

        //clean chart area
        
        this.cleanChartArea();
        this.drawChartArea();

        for (let i = 0; i < intervals; i++) {
            
            let freq = frequencies[i] || 0;  // Se il valore non esiste, usa 0
            let barWidth = freq * barWidthUnit - 1;  // Altezza della barra in base alla frequenza 

            let yIntervals = this.height/intervals;

            let yInit =  - this.y + yIntervals; //still wondering why i have to subtract the y
            
            let yPlot = yInit + i*yIntervals;
                        
            //INTERVALS LINES 
            // let intLines = new Path2D();
            // this.ctx.strokeStyle = 'black';
            // drawPathLine(this.x, yPlot, this.x + this.width, yPlot, intLines, this.height); 
            // this.ctx.stroke(intLines);
            
            let path = new Path2D();
            this.ctx.lineWidth = 7;
            this.ctx.strokeStyle = 'yellow';
            drawPathLine(this.x + 40, yPlot - yIntervals/2 - this.ctx.lineWidth, this.x + barWidth + 40, yPlot - yIntervals/2 - this.ctx.lineWidth, path, this.height);
            this.ctx.stroke(path);

            console.log(labels[i], freq, barWidth, yPlot);
            if(labels === undefined) continue;
            this.ctx.font = "20px Arial";
            this.ctx.fillStyle = 'black';
            this.ctx.fillText(labels[i] || "~", this.x + 10, this.height - (yPlot - yIntervals/2 - this.ctx.lineWidth));

            // drawRect(this.x, (yPlot - yIntervals/2 + yIntervals/4)*scaleFactor, barWidth, yIntervals/2, this.ctx, this.height);
            // break;
        }
    }


    // Function to plot the vertical histogram
    plotVertical(frequencies, scaleFactor, intervals) {
        let maxVal = arrMax(frequencies); // Find the maximum
        let barHeightUnit = (this.height) / maxVal;

        // Clean chart area
        this.cleanChartArea();
        this.drawChartArea();

        for (let i = 0; i < intervals; i++) {
            let freq = frequencies[i] || 0;  // If the value does not exist, use 0
            let barHeight = freq * barHeightUnit;  // Height of the bar based on the frequency

            let xIntervals = this.width / intervals;
            let xInit = this.x + xIntervals; // Initial x position

            let xPlot = xInit + i * xIntervals;

            let path = new Path2D();
            this.ctx.lineWidth = 7;
            this.ctx.strokeStyle = 'yellow';
            drawPathLine(xPlot - xIntervals / 2 - this.ctx.lineWidth, this.y + this.height, xPlot - xIntervals / 2 - this.ctx.lineWidth, this.y + this.height - barHeight, path, this.height);
            this.ctx.stroke(path);
        }
    }
    
    plotEMS(frequencies,mode, nsteps){
            //cleans and redraw the area
        this.cleanChartArea();
        this.drawChartArea();

        let maxVal = arrMax(frequencies); //find the maximum
        
        let scaleFactor = STEP/4;

        if(mode === "rel")
            scaleFactor = (this.height/(2*nsteps));
        if(mode === "norm")
            scaleFactor = Math.sqrt(this.height)/(2*Math.sqrt(nsteps));

        let barWidthUnit = (this.width-1)/maxVal;
        let xPos = this.x;

        let Histogram = [];
        this.ctx.lineWidth = 7;
        this.ctx.strokeStyle = 'yellow';

        for (let i = 0; i < frequencies.length; i++) {

            let freq = frequencies[i] || 0;  // Se il valore non esiste, usa 0
            let barWidth = freq * barWidthUnit;  // Altezza della barra in base alla frequenza 
            
            let yInit = -this.y + lineChartHeight/2;
            let yPos = yInit + i*scaleFactor - (nsteps-i)*scaleFactor
            let entry = new Path2D();
            console.log("ypos", yPos, "xpos", xPos);
            drawPathLine(xPos, yPos,xPos + barWidth, yPos , entry, this.height);
            Histogram.push(entry);
            this.ctx.stroke(entry);
        }
        return Histogram;
    }

}

function drawLine(xi, yi, xf, yf, ctx){
    ctx.beginPath();

    ctx.moveTo(xi,canvas.height-yi);
    ctx.lineTo(xf,canvas.height-yf);

    // Draw the Path
    ctx.stroke();
    ctx.closePath();
}

function drawRect(x, y, rwidth, rheight, ctx, canvaheight){
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'yellow';
    //invert y
    ctx.fillRect(x, canvaheight - y, rwidth, rheight);
}

function drawPathLine(xi, yi, xf, yf, path, height){
    path.moveTo(xi, height-yi);
    path.lineTo(xf, height-yf);
}

// dev(n) = dev(n-1) + (x(n)- x(n-1))*(x(n)-mean(n))

